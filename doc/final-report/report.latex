\documentclass[a4paper,11pt]{article}
\usepackage[a4paper,vmargin={20mm,20mm},hmargin={30mm,25mm}]{geometry}

\usepackage{graphicx}
\usepackage[utf8x]{inputenc}
\usepackage[english,ngerman]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{verbatim}
%\usepackage{color}
\usepackage{amssymb,amsmath}

% this makes < > work
\usepackage[T1]{fontenc}

\PrerenderUnicode{ü}

\usepackage[pdftex,
            pdfauthor={Sebastian Kürten},
            pdftitle={Apollonius-Diagramme in der Geokodierung},
            pdfsubject={Erstellung von Apollonius-Diagrammen auf Basis von Openstreetmap mit CGAL},
            pdfkeywords={CGAL, Apollonius, Voronoi, Openstreetmap, Geocoding, Geokodierung},
            pdfproducer={Latex with hyperref},
            pdfcreator={pdflatex}]{hyperref}

\hypersetup{
	linkcolor=[rgb]{0 0 0.5},
        colorlinks=true,
        %linktocpage=true,
        linkbordercolor=blue,
        menucolor=red
}

\begin{document}

\selectlanguage{english}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Header
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\parindent 0em%
\parskip 0.5em%
\noindent\rule{\textwidth}{1pt}%
\begin{center}%
\textbf{Softwareprojekt CGAL} \\
\textbf{WiSe 2012/13}
\end{center}%
{Philipp Borgers, Sebastian Kürten, Lukas Maischak}\\%
\noindent\rule{\textwidth}{1pt}%

\definecolor{light-gray}{gray}{0.9}
\lstset {language = c}
\lstset {numbers = left, frame = single}
\lstset {breaklines = true}
\lstset {basicstyle = \footnotesize, numberstyle = \small\color{gray}}
\lstset {literate = {Ö}{{\"O}}1 {Ä}{{\"A}}1 {Ü}{{\"U}}1 {ß}{{\ss}}2 {ü}{{\"u}}1 {ä}{{\"a}}1 {ö}{{\"o}}1 }

\newcommand*{\DOT}{.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Table of contents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

\subsection{Topic / General Idea}
\begin{itemize}
\item Problem: approximate the actual polygonal representation of a municipality 
given a puntal representation of such a geographic entity.
\item TODO: cite some literature: naive approach is nearest neighbours
\item Nearest neighbours = implicit usage of ordinary voronoi diagram
\item Idea: use the \textbf{weighted Voronoi diagram} a.k.a. the
\textbf{Apollonius diagram} to produce more accurate representations of municipalities.
\end{itemize}

\subsection{Project outline}

\begin{itemize}
\item CGAL implements the Apollonius diagram within the \textbf{2D Apollonius Graphs} package.
\item Construct such a diagram for arbitrary input data
\item For ease of further use extract the cells of the Apollonius diagram as polygons
\item Utilize the \textbf{2D Regularized Boolean Set-Operations} package to make it possible
to refine the results of diagram creation by computing the intersection with some additional
bounding polygon.
\item Visualize input and output data appopriately so that results may be inspected manually
and to create a qualitative measure for usefulness of the results
\item Evaluate results quantitatively with sophisticated input data for the municipalities of
Germany. Develope methods for evaluating the accurateness of the diagrams created and compare them
to the original data that is available.
\end{itemize}

\subsection{Architecture}
\label{sec:intro-architecture}

Our implementation has four major components:
\begin{itemize}
\item Preprocessing (written in Java)
\item Generation of Apollonius diagram cells (written in C using CGAL)
\item Intersection of Apollonius cells with a bounding polygon (written in C
using CGAL)
\item Evaluation code (written in Java)
\end{itemize}

Section \ref{sec:impl} is structured accordingly.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The Apollonius diagram
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Apollonius Diagram}

\subsection{Introduction}

Lorem ipsum

\subsection{Primal and Dual}
\label{sec:apo-primal-dual}

Lorem ipsum

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Relevant CGAL packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Relevant CGAL packages}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 2D Apollonius Graphs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{2D Apollonius Graphs}

In this section we describe briefly most basic operations available on the 
2D Apollonius graph data structure. Some methods have been left out 
because they are not relevant to our project.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Creation and basic operations}
The \textbf{2D Apollonius Graphs} package provided by CGAL does not offer 
any means to create the Apollonius diagram directly but rather offers 
means for creating its dual, the \textbf{Apollonius graph}.
An Apollonius graph instance may then be used to answer the typical queries 
to the diagram itsself, most importantly the nearest neighbor query which,
given a point, returns the site of the diagram that is closest to that point
with respect to the metric defined for additiveley weighted voronoi diagrams.

The data structures implemented in the package allow dynamic insertions and
deletions to the Apollonius graph.
Assuming you declared an instance of Apollonius graph like this:

\begin{lstlisting}[numbers=none]
Apollonius_graph ag;
\end{lstlisting}

Then inserting a site $s$ into the graph is as easy as calling: 

\begin{lstlisting}[numbers=none]
ag.insert (Site_2 s);
\end{lstlisting}

Similarly a site may be removed from the graph like this:

\begin{lstlisting}[numbers=none]
ag.remove (Vertex_handle v);
\end{lstlisting}

assuming that you have a valid vertex handle $v$ at hand.

The site whose cell a point $p$ falls within may then be found by executing
the nearest neighbor query as follows:

\begin{lstlisting}[numbers=none]
ag.nearest_neighbor (Point_2 p);
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Access to basic constituent elements of the graph}

The Apollonius graph data structure offers various iterators and circulators
in respect to the constituent parts of the graph. 

The elements the graph has been constructed from are the sites that have
been inserted into the graph. Access to these sites is provided via
iterators over sites. One might iterate over all sites available or, by 
choice of the appropriate method, either only over visible or only 
over invisble sites:
\begin{itemize}
\item \texttt{ag.sites\_begin} and \texttt{ag.sites\_end},
\item \texttt{ag.visible\_sites\_begin} and \texttt{ag.visible\_sites\_end},
\item \texttt{ag.hidden\_sites\_begin} and \texttt{ag.hidden\_sites\_end}.
\end{itemize}

It is possible to iterate
over all vertices, edges and faces of the graph. The class offers the 
following methods to access these elements:
\begin{itemize}
\item \texttt{ag.all\_vertices\_begin} and \texttt{ag.all\_vertices\_end},
\item \texttt{ag.all\_edges\_begin} and \texttt{ag.all\_edges\_end},
\item \texttt{ag.all\_faces\_begin} and \texttt{ag.all\_faces\_end}.
\end{itemize}

Additionally, the class offers similar methods for the iteration over only
the finite elements of the graph:
\begin{itemize}
\item \texttt{ag.finite\_vertices\_begin} and \texttt{ag.finite\_vertices\_end},
\item \texttt{ag.finite\_edges\_begin} and \texttt{ag.finite\_edges\_end},
\item \texttt{ag.finite\_faces\_begin} and \texttt{ag.finite\_faces\_end}
\end{itemize}

Once you have a vertex $v$ at hand, you may also circulate over incident
elements within the graph:
\begin{itemize}
\item \texttt{ag.incident\_faces(Vertex\_handle v)},
\item \texttt{ag.incident\_edges(Vertex\_handle v)},
\item \texttt{ag.incident\_vertices(Vertex\_handle v)}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Visualization}

Basic visualization mechanisms are available so that the Apollonius graph
and its dual diagram may be displayed via Qt for example.
For this purpose the following methods are defined either to draw the
complete graph or individual parts thereof:

\begin{itemize}
\item \texttt{ag.draw\_primal(Stream str)},
\item \texttt{ag.draw\_dual(Stream str)},
\item \texttt{ag.draw\_primal\_edge(Edge e, Stream str)},
\item \texttt{ag.draw\_dual\_edge(Edge e, Stream str)}.
\end{itemize}

As argument to these methods an instance of \texttt{PainterOstream} 
provided by the CGAL library may be used to draw the diagram to an instance
of \texttt{QPainter} which is in turn provided by the Qt-Framework.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Access to the dual}

As described in section \ref{sec:apo-primal-dual}, each basic component of
the Apollonius graph has a dual with respect to the Apollonius diagram.

% NOTE: wow. the documentation at 'Class_Apollonius_graph_2.html' is wrong
% about this. The dual of a face of the graph is not a site but a vertex

The Apollonius graph class publicly offers access to the dual of faces only.
A handle or iterator to a face $f$ of the graph at hand, one might access the
dual of that face, which is a vertex of a cell of the Apollonius diagram, by
using this method:

\texttt{ag.dual (Face\_handle f)}

Unfortunately, the access to the dual of the remaining basic parts of the 
graph is not publicly exposed to the user of the library.
Nevertheless, access to those elements has been needed for the construction 
of polygons for the cells of the diagram.
This will be discussed in more detail in section \ref{sec:impl-apo-polygon-creation}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 2D Regularized Boolean Set-Operations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{2D Regularized Boolean Set-Operations}

Lorem ipsum

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Core Implementation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Core Implementation}
\label{sec:impl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Prepreocessing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Preprocessing}
\label{sec:impl-preprocessing}

Input data has been extracted from data from the Openstreetmap project.
Because the project gathers a huge amount of data, only the relevant data
of interest had to be extracted so that this data may be processed
conviniently.

Data found in Openstreetmap carries alphanumerical information along with 
spatial attributes. It is possible to store the basic geometric types point,
linestring, polygon and region (polygon with holes and multiple outer
boundaries) in Openstreetmap and a variety of so called tags is used to
annotate data quite flexibly. A tag in this context referes to 
the notion of storing a value in association to a key.

The subset of data we were interested in were the \textit{city nodes}, i.e.
those nodes in the database that describe the locations of cities.
These nodes are identified by a tag with the key \textit{place} and an
associated value of either \textit{city}, \textit{town} or \textit{village}.
This tag does not only identify cities as such but at the same time
categeories the size of a city in respect to its population.
A value of \textit{city} means that a place has more than 100000 inhabitants,
while a value of \textit{town} or \textit{village} stands for more than
10000 or more than 1000 inhabitants respectfully.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Extracting relevant data from Openstreetmap}
\label{sec:impl-preprocessing-extraction}

The following program implemented in Java extracts the desired data from an
input file with Openstreetmap data and writes it to a file in simple text
format.

\lstinputlisting[language=java]{code/preprocessing.java}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Apollonius cell generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Apollonius cell generation}
\label{sec:impl-apo}

This part of our implementation takes as input a file that contains a 
list of input nodes as 
described in section \ref{sec:impl-preprocessing}, constructs the 
Apollonius graph, transforms each cell to a polygonal entity and exports
each polygon to a file for further usage.

The main program is called \texttt{create\_polygons} and accepts six 
input parameters:

\begin{enumerate}
\item \textbf{Input}. This is the name of a file that contains the node 
definitions.
\item \textbf{Output}. This is the name of directory where to program will
put the generated polygon files.
\item \textbf{File format}. This is either "wkt" or "geojson" and defines 
which type of output file will be generated.
\item \textbf{Weight for cities}. The weight used to \textit{city} nodes.
\item \textbf{Weight for towns}. The weight used for \textit{town} nodes.
\item \textbf{Weight for villages}. The weight used for \textit{village} nodes.
\end{enumerate}

For example the program may be called from the command line like this:

\begin{lstlisting}[numbers=none]
./create_polygons nodes.txt output/ wkt 1.0 0.5 0.1
\end{lstlisting}

\subsubsection{Program setup}
\label{sec:impl-apo-setup}

After parsing the command line parameters, the program attempts to read
in the list of sites supplied as a file.
The method \texttt{readSites} returns a variable of type \texttt{SiteList}
which is essentially a std vector of \texttt{Site\_2} instances.
This \texttt{SiteList} will then be the input to further computations.

\lstinputlisting{code/read-sites.c}

\subsubsection{Creating the Apollonius diagram}
\label{sec:impl-apo-creation}

First the algorithm computes the bounding box of the input sites so that
artificial may be created by mirroring along the axis' of the bounding box.
The following method is used for calculation of the bounding box:

\lstinputlisting{code/bbox.c}

Next the list of artificial sites is created by mirroring each input site
at each of the four axis' of the bounding box:

\lstinputlisting{code/artificial.c}

With input sites and artificial sites at hand, the apollonius graph
is created like this:

\lstinputlisting{code/init-apollonius-graph.c}

\subsubsection{Accessing the cells and converting them to polygons}
\label{sec:impl-apo-polygon-creation}

For each site, we create the cell as a polygon by traversing the 
incident edges to the vertex of the site in circular order.
Each edge in the Apollonius graph has as dual an edge in the Apollonius
diagram.
We retrieve this dual edge, create a discretized version of it in form
of a list of points that approximates the curve and add this list of points
to the list of arcs that form the cell.

\lstinputlisting{code/cell.c}

In the above code, the method \texttt{handleDual} will inspect type of 
the object passed as the first argument and add a polyline to the list
of polylines which is given as the third argument and possibly clip
inifinite arcs with the clipping rectangle. The implementation of
handleDual is shown at the end of this section.

By circulating the incident edges of the site above to collect, via their 
dual, the arcs of the apollonius cells, we ensured that the arcs arrive
in the list of arcs in their correct order in respect to the order of arcs
forming the cell.
Only we cannot know whether an arc is in the correct order with respect to 
itself (i.e. whether its direction is correct), 
because the method we use to create approximations for curves makes no 
guarantees about the direction of the arc returned.
To resolve this situtation, the following method has been written that
reverses the direction of arcs if necessary.

\lstinputlisting{code/build-polygon.c}

The next method is \texttt{handleDual} which generates a list of points
for an arc and adds this pointlist to a list of pointlists for later 
assemblage.

The method determines the type of the arc and delegates each call to special 
implementations of \texttt{handleDual} for specific types of arcs.

\lstinputlisting{code/handle-dual.c}

It is noteworthy that the cases of Line, Hyperbola, Ray and Hyperbola ray
 cannot occur in the disambiguation anymore.
This is true because the insertion of the artifical sites into the 
graph prevents infinite points to be possible for the cells of the original
input sites. The methods for Ray and Hyperbola ray are shown here for 
completenes while those of Line and Hyperbola are left out.

\lstinputlisting{code/handle-dual-disamb.c}

\subsubsection{Exporting geometries for further usage}
\label{sec:impl-apo-exporting}

Simple algorithms have been implemented to output the created polygons to
some important and easy to reuse file formats.
The algorithms are this simple because they assume the polygon to be of its
simplest possible form with only one outer ring forming the boundary of
the polygon.
Two formats have been implemented because each of them makes further 
processing with a specific tool quite easy.

\paragraph{Well-Known-Text (WKT)}

The following code implements output in the Well-Known-Text format:

\lstinputlisting{code/wkt.c}

\paragraph{GeoJSON}

The following code implements output in the GeoJSON format:

\lstinputlisting{code/geojson.c}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Apollonius cell insersection
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Insersecting geometries with a polygonal boundary}
\label{sec:impl-cell-intersection}

Lorem ipsum

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Evaluation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Evaluation implementation}
\label{sec:impl-evaluation}

The purpose of this program is to measure the resemblance of the polygonal
representation of a city as created by our Apollonius diagram program to
the original, known, boundary of that city.

The idea is, once we have a quantitative measure at hand, we are able to
learn the parameters for our diagram creation algorithm by an appropriate
machine learning algorithm.

Accordingly the problem here presents as follows:
\begin{itemize}
\item Input: a set of input regions $\mathbb{P}$ and a set of 
associated output regions $\mathbb{Q}$ produced by our Apollonius program.
For each region $p \in \mathbb{P}$ there is either an associated region 
$p' \in \mathbb{Q}$ that has been produced by our algorithm or no such
associated $p'$ exists because the respective site has been a hidden site 
in the Apollonius diagram.
\item Output: compute an overall measure of the quality of the resemblance
of the geometries.
\end{itemize}

The measure of resemblance has been implemented by working on a set of
test points $\mathbb{T}$ that lie within the region covered by the input
geometries.
To determine the resemblance factor, the following has been done:
\begin{itemize}
\item Initialize a counter variable $correct$ with $0$.
\item For each $t \in \mathbb{T}$, find the original region 
$p \in \mathbb{P}$ that contains $t$, as well as the Apollonius region
$p' \in \mathbb{Q}$ that contains $t$.
\item If $p'$ is associated with $p$, increment $correct$.
\item In the end, determine the resemblance factor
as $$resemblance = \frac{correct}{|\mathbb{T}|}$$
\end{itemize}

Two different types of measurement strategies have been implemented.
They differ in the way the set of input points $\mathbb{T}$ have been
selected.
\begin{itemize}
\item The first strategy aims to select $\mathbb{T}$ uniformly distributed
over the covered region. The resemblance measure should reflect the 
real geometric resemblance of the shapes under consideration.
\item The second strategy uses as test set $\mathbb{T}$ the centroids of
all streets stored in Openstreetmap for the area covered by input regions.
The idea is that the resemblance factor reflects a measure of how good
certain real data may be georeferenced with the geometries produced by our 
Apollonius diagrams.
\end{itemize}


The evaluation program has been implemented in Java. Both algorithms
work with a list of input identifiers $ids$ for iteration purposes,
as well as mappings from 
such ids to source and apollonius geometries specified with
variables $idToSourceGeometry$ and $idToApolloniusGeometry$ respectfully.

This is the code for the first resemblance measuremente strategy:
\lstinputlisting[language=java]{code/eval-strategy1.java}

This is the code for the second resemblance measuremente strategy:
\lstinputlisting[language=java]{code/eval-strategy2.java}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Evaluation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Evaluation}

\subsection{Qualitative Results}

\subsection{Quantitative Analysis}

The algorithms described in section \ref{sec:impl-evaluation} have been used
on the one hand to find good parameters needed as input for the algorithm
that creates the Apollonius diagram and on the other hand to estimate the
quality of the results quantitatively. In this section we present the 
results of these quality measurements.

\begin{figure}
\begin{tabular}{|l|l|l|l|}\hline
resemblance factor & weight city & weight town & weight village \\\hline\hline
\input{data/data-uniform.tex}
\end{tabular}
\caption{Uniform data: resemblance mesaure}
\end{figure}

\begin{figure}
\begin{tabular}{|l|l|l|l|}\hline
resemblance factor & weight city & weight town & weight village \\\hline\hline
\input{data/data-highways.tex}
\end{tabular}
\caption{Street data: resemblance mesaure}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Summary
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
\subsection{Summary}
\subsection{Look-out}

\end{document}
