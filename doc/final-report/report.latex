\documentclass[a4paper,11pt]{article}
\usepackage[a4paper,vmargin={20mm,20mm},hmargin={30mm,25mm}]{geometry}

\usepackage{graphicx}
\usepackage[utf8x]{inputenc}
\usepackage[english,ngerman]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{verbatim}
%\usepackage{color}
\usepackage{amssymb,amsmath}
\usepackage{multibib}

\usepackage{caption}
\usepackage{subcaption}

% this makes < > work
\usepackage[T1]{fontenc}

\PrerenderUnicode{ü}

\usepackage[pdftex,
            pdfauthor={Sebastian Kürten},
            pdftitle={Apollonius-Diagramme in der Geokodierung},
            pdfsubject={Erstellung von Apollonius-Diagrammen auf Basis von Openstreetmap mit CGAL},
            pdfkeywords={CGAL, Apollonius, Voronoi, Openstreetmap, Geocoding, Geokodierung},
            pdfproducer={Latex with hyperref},
            pdfcreator={pdflatex}]{hyperref}

\hypersetup{
	linkcolor=[rgb]{0 0 0.5},
        colorlinks=true,
        %linktocpage=true,
        linkbordercolor=blue,
        citecolor=blue,
	urlcolor=blue,
        menucolor=red
}

\begin{document}

\selectlanguage{english}
\numberwithin{figure}{section}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Header
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\parindent 0em%
\parskip 0.5em%
\noindent\rule{\textwidth}{1pt}%
\begin{center}%
\textbf{Softwareprojekt CGAL} \\
\textbf{WiSe 2012/13}
\end{center}%
{Philipp Borgers, Sebastian Kürten, Lukas Maischak}\\%
\noindent\rule{\textwidth}{1pt}%

\definecolor{light-gray}{gray}{0.9}
\lstset {language = c}
\lstset {numbers = left, frame = single}
\lstset {breaklines = true}
\lstset {basicstyle = \footnotesize, numberstyle = \small\color{gray}}
\lstset {literate = {Ö}{{\"O}}1 {Ä}{{\"A}}1 {Ü}{{\"U}}1 {ß}{{\ss}}2 {ü}{{\"u}}1 {ä}{{\"a}}1 {ö}{{\"o}}1 }

\newcommand*{\DOT}{.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Table of contents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

\subsection{Topic / General Idea}
\begin{itemize}
\item Place names are widely used in the context of geographic information
systems\cite{alani2001voronoi}.
\item Typically the geometric information is only available as a simple
footprint in form of a centroid coordinate\cite{alani2001voronoi}.
\item This is also true for the point based place information 
found within the data of the Openstreetmap 
project\footnote{http://wiki.openstreetmap.org/wiki/Places}.
\item Interesting problem: approximate a more accurate spatial footprint
of places\cite{alani2001voronoi}.
\item Different methods have been developed to compute approximation 
from different kinds of additional information\cite{schockaert2005automatic}.
\item A really basic approach that does not require additional information
is the usage of Voronoi diagram with the places as input sites to create a 
polygonal spatial footprint for each place.
\item \textbf{Idea}: use the \textbf{weighted Voronoi diagram} a.k.a. the
\textbf{Apollonius diagram} to produce more accurate representations of
municipalities.
Weights for sites may be derived from the type of
place\footnote{http://wiki.openstreetmap.org/wiki/Key:place}.
\end{itemize}

\subsection{Project outline}

\begin{itemize}
\item CGAL implements the Apollonius diagram within the \textbf{2D Apollonius Graphs} package.
\item Construct such a diagram for arbitrary input data.
\item For ease of further use extract the cells of the Apollonius diagram as polygons.
\item Utilize the \textbf{2D Regularized Boolean Set-Operations} package to make it possible
to refine the results of diagram creation by computing the intersection with some additional
bounding polygon.
\item Visualize input and output data appopriately so that results may be inspected manually
and to create a qualitative measure for usefulness of the results.
\item Evaluate results quantitatively with sophisticated input data for the municipalities of
Germany. Develope methods for evaluating the accurateness of the diagrams created and compare them
to the original data that is available.
\end{itemize}

\subsection{Architecture}
\label{sec:intro-architecture}

Our implementation has four major components:
\begin{itemize}
\item Preprocessing (written in Java)
\item Generation of Apollonius diagram cells (written in C++ using CGAL)
\item Intersection of Apollonius cells with a bounding polygon (written in C++
using CGAL)
\item Evaluation code (written in Java)
\end{itemize}

Section \ref{sec:impl} which describes the implementation in detail is 
structured accordingly.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The Apollonius diagram
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Apollonius Diagram}

\subsection{Introduction}

% citing CGAL: http://www.cgal.org/bibliography.html
%\footnote{http://www.cgal.org/Manual/latest/doc\_html/cgal\_manual/Apollonius\_graph\_2/Chapter\_main.html}:

The following definition of the Apollonius diagram can be found in the 
CGAL user manual\cite{cgal:ky-ag2-12b}:
\begin{quote}
The Apollonius diagram
in the plane is defined over a set of sites $P_i = (c_i, w_i),
i = 1, ..., n$ where $c_i$ is the point and $w_i$ the weight of $P_i$. It is a
subdivision of the plane into connected regions, called cells, associated with
the sites. The cell of a site $Pi$ is the locus of points on the plane that are
closer to $P_i$ than any other site $P_j, j \neq i$. The distance $\delta(x, P_i)$ of a
point $x$ in the plane to a site $Pi$ is defined as:

$\delta(x,P_i)=||x-c_i||-w_i$,

where $|| ⋅ ||$ denotes the Euclidean norm.
\end{quote}

The Apollonius diagram is also called Additively weighted Voronoi diagram
because of its close relationship to the Voronoi diagram, which it is a
generalization of.
An Apollonius diagram with equal weights for each site is a Voronoi diagram.

The Apollonius graph is the dual of the Apollonius diagram.
The geometric properties of both are described in a report by 
Karavelas and Yvinec\cite{yvinec2002dynamic} and will be discussed in 
the following section.

\begin{figure}[htp]
        \centering
        \begin{subfigure}[b]{0.48\textwidth}
                \centering
                \includegraphics[width=\textwidth]{images/apollonius-graph.png}
                \caption{Apollonius graph}
                \label{fig:apo-graph}
        \end{subfigure}
        \begin{subfigure}[b]{0.48\textwidth}
                \centering
                \includegraphics[width=\textwidth]{images/apollonius-diagram.png}
                \caption{Apollonius diagram}
                \label{fig:apo-diagram}
        \end{subfigure}
        \caption{Apollonius graph and Apollonius diagram}\label{fig:apollonius}
\end{figure}

\subsection{Properties of the diagram und the dual Delaunay graph}
\label{sec:apo-primal-dual}

The Apollonius diagram is a subdivision of the plane into connected regions.
Those regions are called cells and all cells are associated with input 
sites.
Figure \ref{fig:apo-diagram} shows an example of such a diagram.
Each site is a point on the plane with an associated weight
and the diagram may be interpreted as a Voronoi diagram of discs where
the radius of each disc depends on the weight of the site.
Unlike with ordinary Voronoi diagrams, not necessarily every site has an 
associated cell in the diagram because it may happen that a site becomes
\textit{hidden}. This happens when the disc of one input site is completely
covered by another site's disc. Hidden sites are called \textit{trivial}.
In figure \ref{fig:apo-diagram} trivial sites are shown in grey whereas
nontrivial sites are shown in red.
Boundaries of cells are defined by straight or hyperbolic arcs and are 
depicted as blue arcs in the figure.

As with Voronoi diagrams, there exists a dual graph for the Apollonius 
diagram that is closely related to the diagram itself and is called the
Apollonius graph.
The Apollonius graph is a planar, connected graph whose
vertices are the nontrivial sites of the Apollonius diagram.
Figure \ref{fig:apo-graph} shows the corresponding dual graph to the 
diagram in \ref{fig:apo-diagram}.

Individual components of graph and diagram are closely related:
\begin{itemize}
\item Nodes of the graph correspond to cells in the diagram.
\item An arc in the graph corresponds to an edge of a cell in the diagram.
\item If two cells of the diagram are connected, there is an arc between
the corresponding nodes of the graph.
\end{itemize}

The Apollonius graph is especially relevant in the context of this
sowftware project because
the package implemented in CGAL maintains the Apollonius graph instead
of the Apollonius diagram internally.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Relevant CGAL packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Relevant CGAL packages}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 2D Apollonius Graphs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{2D Apollonius Graphs}

In this section we describe briefly most basic operations available on the 
2D Apollonius graph data structure. Some methods have been left out 
because they are not relevant to our project.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Creation and basic operations}
The \textbf{2D Apollonius Graphs} package provided by CGAL does not offer 
any means to create the Apollonius diagram directly but rather offers 
means for creating its dual, the \textbf{Apollonius graph}.
An Apollonius graph instance may then be used to answer the typical queries 
to the diagram itsself, most importantly the nearest neighbor query which,
given a point, returns the site of the diagram that is closest to that point
with respect to the metric defined for additiveley weighted Voronoi diagrams.

The data structures implemented in the package allow dynamic insertions and
deletions to the Apollonius graph.
Assuming you declared an instance of Apollonius graph like this:

\begin{lstlisting}[numbers=none]
Apollonius_graph ag;
\end{lstlisting}

Then inserting a site $s$ into the graph is as easy as calling: 

\begin{lstlisting}[numbers=none]
ag.insert (Site_2 s);
\end{lstlisting}

Similarly a site may be removed from the graph like this:

\begin{lstlisting}[numbers=none]
ag.remove (Vertex_handle v);
\end{lstlisting}

assuming that you have a valid vertex handle $v$ at hand.

The site whose cell a point $p$ falls within may then be found by executing
the nearest neighbor query as follows:

\begin{lstlisting}[numbers=none]
ag.nearest_neighbor (Point_2 p);
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Access to basic constituent elements of the graph}

The Apollonius graph data structure offers various iterators and circulators
in respect to the constituent parts of the graph. 

The elements the graph has been constructed from are the sites that have
been inserted into the graph. Access to these sites is provided via
iterators over sites. One might iterate over all sites available or, by 
choice of the appropriate method, either only over visible or only 
over invisble sites:
\begin{itemize}
\item \texttt{ag.sites\_begin} and \texttt{ag.sites\_end},
\item \texttt{ag.visible\_sites\_begin} and \texttt{ag.visible\_sites\_end},
\item \texttt{ag.hidden\_sites\_begin} and \texttt{ag.hidden\_sites\_end}.
\end{itemize}

It is possible to iterate
over all vertices, edges and faces of the graph. The class offers the 
following methods to access these elements:
\begin{itemize}
\item \texttt{ag.all\_vertices\_begin} and \texttt{ag.all\_vertices\_end},
\item \texttt{ag.all\_edges\_begin} and \texttt{ag.all\_edges\_end},
\item \texttt{ag.all\_faces\_begin} and \texttt{ag.all\_faces\_end}.
\end{itemize}

Additionally, the class offers similar methods for the iteration over only
the finite elements of the graph:
\begin{itemize}
\item \texttt{ag.finite\_vertices\_begin} and \texttt{ag.finite\_vertices\_end},
\item \texttt{ag.finite\_edges\_begin} and \texttt{ag.finite\_edges\_end},
\item \texttt{ag.finite\_faces\_begin} and \texttt{ag.finite\_faces\_end}
\end{itemize}

Once you have a vertex $v$ at hand, you may also circulate over incident
elements within the graph:
\begin{itemize}
\item \texttt{ag.incident\_faces(Vertex\_handle v)},
\item \texttt{ag.incident\_edges(Vertex\_handle v)},
\item \texttt{ag.incident\_vertices(Vertex\_handle v)}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Visualization}

Basic visualization mechanisms are available so that the Apollonius graph
and its dual diagram may be displayed via Qt for example.
For this purpose the following methods are defined either to draw the
complete graph or individual parts thereof:

\begin{itemize}
\item \texttt{ag.draw\_primal(Stream str)},
\item \texttt{ag.draw\_dual(Stream str)},
\item \texttt{ag.draw\_primal\_edge(Edge e, Stream str)},
\item \texttt{ag.draw\_dual\_edge(Edge e, Stream str)}.
\end{itemize}

As argument to these methods an instance of \texttt{PainterOstream} 
provided by the CGAL library may be used to draw the diagram to an instance
of \texttt{QPainter} which is in turn provided by the Qt-Framework.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Access to the dual}

As described in section \ref{sec:apo-primal-dual}, each basic component of
the Apollonius graph has a dual with respect to the Apollonius diagram.

% NOTE: wow. the documentation at 'Class_Apollonius_graph_2.html' is wrong
% about this. The dual of a face of the graph is not a site but a vertex

The Apollonius graph class publicly offers access to the dual of faces only.
A handle or iterator to a face $f$ of the graph at hand, one might access the
dual of that face, which is a vertex of a cell of the Apollonius diagram, by
using this method:

\texttt{ag.dual (Face\_handle f)}

Unfortunately, the access to the dual of the remaining basic parts of the 
graph is not publicly exposed to the user of the library.
Nevertheless, access to those elements has been needed for the construction 
of polygons for the cells of the diagram.
This will be discussed in more detail in section \ref{sec:impl-apo-polygon-creation}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 2D Regularized Boolean Set-Operations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{2D Regularized Boolean Set-Operations}

Lorem ipsum

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Core Implementation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Core Implementation}
\label{sec:impl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Prepreocessing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Preprocessing}
\label{sec:impl-preprocessing}

Input data has been extracted from data from the Openstreetmap project.
Because the project gathers a huge amount of data, only the relevant data
of interest had to be extracted so that this data may be processed
conveniently.

Data found in Openstreetmap carries alphanumerical information along with 
spatial attributes. It is possible to store the basic geometric types point,
linestring, polygon and region (polygon with holes and multiple outer
boundaries) in Openstreetmap and a variety of so called tags is used to
annotate data quite flexibly. A tag in this context referes to 
the notion of storing a value in association to a key.

The subset of data we were interested in were the \textit{city nodes}, i.e.
those nodes in the database that describe the locations of cities.
These nodes are identified by a tag with the key \textit{place} and an
associated value of either \textit{city}, \textit{town} or \textit{village}.
This tag does not only identify cities as such but at the same time
categeories the size of a city in respect to its population.
A value of \textit{city} means that a place has more than 100 000 inhabitants,
while a value of \textit{town} or \textit{village} stands for more than
10 000 or more than 1 000 inhabitants respectively.

The following listing is an example of valid input data in a simple column
based text format that we used for easy processing with our programs.
The first column is the id of the entity as found in the Openstreetmap
database,
the second and third column are longitude and lattitude and the fourth column
contains the category of the place as one of \textit{city}, \textit{town} 
or \textit{village}.

\lstinputlisting{data/place-nodes.txt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Extracting relevant data from Openstreetmap}
\label{sec:impl-preprocessing-extraction}

The following program implemented in Java extracts the desired data from an
input file with Openstreetmap data and writes it to a file in simple text
format.

\lstinputlisting[language=java]{code/preprocessing.java}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Creating an additional training data set}
\label{sec:impl-preprocessing-training-data}

As a second set of data, a training data set has been constructed to work
with. The idea was to create a data set similar to the data set as seen
in the previous section but with the property that more information is
available about this data thus allowing the results of our algorithms to
be evaluated by incorporating this surplus of information.

What we did here is to take exact boundaries of cities in Germany, specified
in form of polygons, from Openstreetmap and reduce their spatial footprint
to a single coordinate by computing the centroid of its polygonal
representation. The resulting dataset has the same spatial characteristics
as the \textit{city nodes} discussed before. What was still missing was
the characterization as one of \textit{city}, \textit{town} or 
\textit{village}. Fortunately the population of the cities could be 
extracted for the polygonal city boundaries which made this categorization
easy.

The following snippet of code creates the desired output format from
a set of files containing polygonal city entities with attached population
information in a tag with key \textit{population}.

\lstinputlisting[language=java]{code/training.java}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Apollonius cell generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Apollonius cell generation}
\label{sec:impl-apo}

This part of our implementation takes as input a file that contains a 
list of input nodes as 
described in section \ref{sec:impl-preprocessing}, constructs the 
Apollonius graph, transforms each cell to a polygonal entity and exports
each polygon to a file for further usage.

The main program is called \texttt{create\_polygons} and accepts six 
input parameters:

\begin{enumerate}
\item \textbf{Input}. This is the name of a file that contains the node 
definitions.
\item \textbf{Output}. This is the name of directory where to program will
put the generated polygon files.
\item \textbf{File format}. This is either "wkt" or "geojson" and defines 
which type of output file will be generated.
\item \textbf{Weight for cities}. The weight used to \textit{city} nodes.
\item \textbf{Weight for towns}. The weight used for \textit{town} nodes.
\item \textbf{Weight for villages}. The weight used for \textit{village} nodes.
\end{enumerate}

For example the program may be called from the command line like this:

\begin{lstlisting}[numbers=none]
./create_polygons nodes.txt output/ wkt 1.0 0.5 0.1
\end{lstlisting}

\subsubsection{Program setup}
\label{sec:impl-apo-setup}

After parsing the command line parameters, the program attempts to read
in the list of sites supplied as a file.
The method \texttt{readSites} returns a variable of type \texttt{SiteList}
which is essentially a std vector of \texttt{Site\_2} instances.
This \texttt{SiteList} will then be the input to further computations.

\lstinputlisting{code/read-sites.c}

\subsubsection{Creating the Apollonius diagram}
\label{sec:impl-apo-creation}

First the algorithm computes the bounding box of the input sites so that
artificial sites may be created by mirroring along the axis' of the bounding box.
The following method is used for calculation of the bounding box:

\lstinputlisting{code/bbox.c}

Next the list of artificial sites is created by mirroring each input site
at each of the four axis' of the bounding box:

\lstinputlisting{code/artificial.c}

With input sites and artificial sites at hand, the Apollonius graph
is created like this:

\lstinputlisting{code/init-apollonius-graph.c}

\subsubsection{Accessing the cells and converting them to polygons}
\label{sec:impl-apo-polygon-creation}

For each site, we create the cell as a polygon by traversing the 
incident edges to the vertex of the site in circular order.
Each edge in the Apollonius graph has as dual an edge in the Apollonius
diagram.
We retrieve this dual edge, create a discretized version of it in form
of a list of points that approximates the curve and add this list of points
to the list of arcs that form the cell.

\lstinputlisting{code/cell.c}

In the above code, the method \texttt{handleDual} will inspect type of 
the object passed as the first argument and add a polyline to the list
of polylines which is given as the third argument and possibly clip
inifinite arcs with the clipping rectangle. The implementation of
handleDual is shown at the end of this section.

By circulating the incident edges of the site above to collect, via their 
dual, the arcs of the Apollonius cells, we ensured that the arcs arrive
in the list of arcs in their correct order in respect to the order of arcs
forming the cell.
Only we cannot know whether an arc is in the correct order with respect to 
itself (i.e. whether its direction is correct), 
because the method we use to create approximations for curves makes no 
guarantees about the direction of the arc returned.
To resolve this situtation, the following method has been written that
reverses the direction of arcs if necessary.

\lstinputlisting{code/build-polygon.c}

The next method is \texttt{handleDual} which generates a list of points
for an arc and adds this pointlist to a list of pointlists for later 
assemblage.

The method determines the type of the arc and delegates each call to special 
implementations of \texttt{handleDual} for specific types of arcs.

\lstinputlisting{code/handle-dual.c}

It is noteworthy that the cases of Line, Hyperbola, Ray and Hyperbola ray
 cannot occur in the disambiguation anymore.
This is true because the insertion of the artifical sites into the 
graph prevents infinite points to be possible for the cells of the original
input sites. The methods for Ray and Hyperbola ray are shown here for 
completenes while those of Line and Hyperbola are left out.

\lstinputlisting{code/handle-dual-disamb.c}

\subsubsection{Exporting geometries for further usage}
\label{sec:impl-apo-exporting}

Simple algorithms have been implemented to output the created polygons to
some important and easy to reuse file formats.
The algorithms are this simple because they assume the polygon to be of its
simplest possible form with only one outer ring forming the boundary of
the polygon.
Two formats have been implemented because each of them makes further 
processing with a specific tool quite easy.

\paragraph{Well-Known-Text (WKT)}

The following code implements output in the Well-Known-Text format:

\lstinputlisting{code/wkt.c}

\paragraph{GeoJSON}

The following code implements output in the GeoJSON format:

\lstinputlisting{code/geojson.c}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Apollonius cell insersection
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Insersecting geometries with a polygonal boundary}
\label{sec:impl-cell-intersection}

Lorem ipsum

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Evaluation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Evaluation implementation}
\label{sec:impl-evaluation}

The purpose of this program is to measure the resemblance of the polygonal
representation of a city as created by our Apollonius diagram program to
the original, known, boundary of that city.

The idea is, once we have a quantitative measure at hand, we are able to
learn the parameters for our diagram creation algorithm by an appropriate
machine learning algorithm.

Accordingly the problem here presents as follows:
\begin{itemize}
\item Input: a set of input regions $\mathbb{P}$ and a set of 
associated output regions $\mathbb{Q}$ produced by our Apollonius program.
For each region $p \in \mathbb{P}$ there is either an associated region 
$p' \in \mathbb{Q}$ that has been produced by our algorithm or no such
associated $p'$ exists because the respective site has been a hidden site 
in the Apollonius diagram.
\item Output: compute an overall measure of the quality of the resemblance
of the geometries.
\end{itemize}

The measure of resemblance has been implemented by working on a set of
test points $\mathbb{T}$ that lie within the region covered by the input
geometries.
To determine the resemblance factor, the following has been done:
\begin{itemize}
\item Initialize a counter variable $correct$ with $0$.
\item For each $t \in \mathbb{T}$, find the original region 
$p \in \mathbb{P}$ that contains $t$, as well as the Apollonius region
$p' \in \mathbb{Q}$ that contains $t$.
\item If $p'$ is associated with $p$, increment $correct$.
\item In the end, determine the resemblance factor
as $$resemblance = \frac{correct}{|\mathbb{T}|}$$
\end{itemize}

Two different types of measurement strategies have been implemented.
They differ in the way the set of input points $\mathbb{T}$ have been
selected.
\begin{itemize}
\item The first strategy aims to select $\mathbb{T}$ uniformly distributed
over the covered region. The resemblance measure should reflect the 
real geometric resemblance of the shapes under consideration.
\item The second strategy uses as test set $\mathbb{T}$ the centroids of
all streets stored in Openstreetmap for the area covered by input regions.
The idea is that the resemblance factor reflects a measure of how good
certain real data may be georeferenced with the geometries produced by our 
Apollonius diagrams.
\end{itemize}


The evaluation program has been implemented in Java. Both algorithms
work with a list of input identifiers $ids$ for iteration purposes,
as well as mappings from 
such ids to source and Apollonius geometries specified with
variables $idToSourceGeometry$ and $idToApolloniusGeometry$ respectively.

This is the code for the first resemblance measuremente strategy:
\lstinputlisting[language=java]{code/eval-strategy1.java}

This is the code for the second resemblance measuremente strategy:
\lstinputlisting[language=java]{code/eval-strategy2.java}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Evaluation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Results and Evaluation}

The quality of generated Apollonius tesselations have been examined
qualitatively by studying the visual appearance of the created cells on
top of a map and quantitatively by measuring the resemblance of the 
approximated cells with a training data set of real city boundaries.

\subsection{Qualitative Results}

The cells of the Apollonius diagram may be displayed on top of a map and
such visualization provides the ability to inspect the characteristics of
the created diagrams. By displaying the cells of the diagram on top of an
ordinary map as a base layer it is possible to get an impression of
the accuracy of the approximated city boundaries. Figure
\ref{fig:apollonius-bb-sachsen} displays the Apollonius diagram created 
for the training data set in a region covering Brandenburg and Saxony.
Figures \ref{fig:dresden} and \ref{fig:berlin} show such overlays in 
detail for the regions around Dresden and Berlin respectively along with
the ordinary Voronoi diagram for the same region.

\begin{figure}[htp]
\begin{center}
\includegraphics[width=\textwidth]{images/bb-sachsen-weighted.png}
\end{center}
\caption{Apollonius diagram for the training data around Brandenburg
and Saxony}
\label{fig:apollonius-bb-sachsen}
\end{figure}

Figure \ref{fig:dresden} shows the city boundaries in the area around 
Dresden approximated with both the Voronoi diagram and the Apollonius
diagram. What one may observe here ist that in certain situations 
the cells produced by the Apollonius diagram appear to approximate
the real boundaries better than those produced by the Voronoi diagram.
Since we assigned a higher weight to the site for Dresden than to
the sites for the surrounding smaller towns, the approximated city 
boundaries are shifted away from the center of Dresden towards the smaller
towns. The result is that greater parts of the true administrative area
of Dresden are included in its approximation.

The situation around Berlin is illustrated in figure \ref{fig:berlin}.
What we can see here is that in both cases the cell created for Berlin
is much smaller than the true boundary of the city.
Although the cell created by the Apollonius diagram is a little bigger
than the one created by the Voronoi diagram, we can observe that neither
method is able to provide a really good approximation of the city.

This shows us on the one hand that the cells of the Apollonius diagram may 
in certain situations create better approximations than the ordinary Voronoi 
diagram but also on the other hand that this method is far from providing 
perfect approximations for true city boundaries.

\begin{figure}[htp]
        \centering
        \begin{subfigure}[b]{0.48\textwidth}
                \centering
                \includegraphics[width=\textwidth]{images/dresden-equal.png}
                \caption{Voronoi diagram}
                \label{fig:dresden-equal}
        \end{subfigure}
        \begin{subfigure}[b]{0.48\textwidth}
                \centering
                \includegraphics[width=\textwidth]{images/dresden-weighted.png}
                \caption{Apollonius diagram}
                \label{fig:dresden-weighted}
        \end{subfigure}
        \caption{Partitioning around Dresden}\label{fig:dresden}
\end{figure}

\begin{figure}
        \centering
        \begin{subfigure}[b]{0.48\textwidth}
                \centering
                \includegraphics[width=\textwidth]{images/berlin-equal.png}
                \caption{Voronoi diagram}
                \label{fig:berlin-equal}
        \end{subfigure}
        \begin{subfigure}[b]{0.48\textwidth}
                \centering
                \includegraphics[width=\textwidth]{images/berlin-weighted.png}
                \caption{Apollonius diagram}
                \label{fig:berlin-weighted}
        \end{subfigure}
        \caption{Partitioning around Berlin}\label{fig:berlin}
\end{figure}

\subsection{Quantitative Analysis}

\subsubsection{Test Data}

As described in section \ref{sec:impl-evaluation}, two different types of
point data have been used for evaluating the resemblance of orignal 
regions with the generated Apollonius regions.

Figure \ref{fig:test-data-uniform} shows a sample of 4.5M points uniformly 
distributed over the test region while figure \ref{fig:test-data-streets} 
shows the 4.8M points of street test data. In both pictures, each test point
has been drawn as a circle with one pixel radius and with an opacity of 1\%.

It can be seen from these pictures that the algorithm for selecting random
test points uniformly appears to work as expected since the whole area 
of concern in figure \ref{fig:test-data-uniform} appears to be nearly 
uniformly colored.

On the other hand figure \ref{fig:test-data-streets} gives an impression of
the nature of the street-based test data. One may observe here how data
is very dense where big cities are and is relatively sparse on the 
countryside.

\begin{figure}[htp]
\begin{center}
\includegraphics[width=\textwidth]{images/points-uniform.png}
\end{center}
\caption{Uniformly distributed test data}
\label{fig:test-data-uniform}
\end{figure}

\begin{figure}[htp]
\begin{center}
\includegraphics[width=\textwidth]{images/points-streets.png}
\end{center}
\caption{Street test data}
\label{fig:test-data-streets}
\end{figure}

\subsubsection{Results}

The algorithms described in section \ref{sec:impl-evaluation} have been used
on the one hand to find good parameters needed as input for the algorithm
that creates the Apollonius diagram and on the other hand to estimate the
quality of the results quantitatively. In this section we present the 
results of these quality measurements.

\begin{figure}[htp]
\centering
\begin{tabular}{|l|l|l|l|}\hline
resemblance factor & weight city & weight town & weight village \\\hline\hline
\input{data/data-uniform.tex}
\end{tabular}
\caption{Uniform data: resemblance mesaure}
\label{tab:data-uniform}
\end{figure}

\begin{figure}[htp]
\centering
\begin{tabular}{|l|l|l|l|}\hline
resemblance factor & weight city & weight town & weight village \\\hline\hline
\input{data/data-highways.tex}
\end{tabular}
\caption{Street data: resemblance mesaure}
\label{tab:data-streets}
\end{figure}

Figure \ref{tab:data-uniform} shows the best 30 values computed for
uniform test point distribution while
figure \ref{tab:data-streets} show the best 30 values computed for 
the street centroids as input points.
In both cases we tried to maximize the resemblance factor by variating 
the parameters and observing the resemblance difference resulting from 
those variations.
In a first step, combinations of parameters in certain ranges with a fixed
stepping have been computed automatically to find the coarse position of
optimal parameter configurations.
In a second step, this process has been refined and further tests have 
been conducted by hand now taking the difference observed into account.
Using binary search between pairs of promising parameters configurations, 
it has not taken too long to locate values that appear to be optimal for
the dataset used.

It can be observed that the resemblance rate observed for the street data
is generally higher that the rate observed for the uniform data.
This is in principle what has been expected what would happen with such
kind of data and this expectancy has led to the selection of this data set 
in the first place.
The best resemblance rate observed for uniform data is 69.59\% while
for street data the best resemblance rate has been 79.23\%.

For the street data based approach, the best parameters found are
0.2425, 0.20, 0.184 as weights for cities, towns and villages respectively,
resulting in a resemblance rate of 79.23\%.
Using the same parameters for the uniformly distributed test data shows
that these parameters come very close to the best parameters observed
for uniformly distributed data in general.
This shows that the parameters found for street data perform quite good
for uniformly distributed data as well.
The opposite is not true:
the best parameters found for uniform data also perform not bad for street
data, but by far not as good as the other way around.
The best parameters for uniform data were 0.23, 0.20 and 0.18, which lead
to a resemblance rate of 78.95\% for street data.

Both tables also include results for the ordinary Voronoi diagram approach,
which is a special case of the Apollonius diagram where all weights are
equal. For uniform data the results for these parameters were around
67.9\% while for street data the resemblance rate was at 74.45\%.
This shows that for uniform data the Apollonius diagram approach has only 
little advantage over the ordinary Voronoi diagram approach where the 
resemblance rate could only be increased from 67.9\% to 69.59\%.
For street data this look a bit different: the resemblance rate
has been increased from 74.45\% to 79.23\%.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Summary
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
\subsection{Summary}
\subsection{Look-out}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliography
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{alpha}
\bibliography{literature}

\end{document}
